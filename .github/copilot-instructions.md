# GitHub Copilot Custom Commands

Ce fichier configure le syst√®me de slash commands personnalis√©es pour GitHub Copilot.

## üéØ Syst√®me de Dispatch ‚Äî INSTRUCTION OBLIGATOIRE

**Quand l'utilisateur tape `/command`, tu DOIS :**

1. **LIRE IMM√âDIATEMENT** le fichier `.github/github-copilot-cmd/command.md` (utilise `read_file`)
2. **EX√âCUTER** les instructions contenues dans ce fichier comme si c'√©tait ton prompt principal
3. **RESPECTER** les `allowed-tools`, `validation`, `rules` d√©finis dans ce fichier
4. **EX√âCUTER TOUTES LES √âTAPES** du workflow ‚Äî ne jamais sauter d'√©tape, notamment les cr√©ations de fichiers

> ‚ö†Ô∏è **CRITIQUE** : Ne r√©ponds JAMAIS √† une commande `/xxx` sans avoir d'abord lu le fichier `xxx.md` correspondant !
>
> ‚ö†Ô∏è **CRITIQUE** : Tu DOIS ex√©cuter **TOUTES** les √©tapes du workflow. Si une √©tape demande de cr√©er un fichier (ex: CHANGENOTE), tu DOIS le faire avec `create_file`.

### Syntaxe

```
/command $ARGUMENTS
```

- `command` ‚Üí nom du fichier `.md` √† charger (sans extension)
- `$ARGUMENTS` ‚Üí param√®tres optionnels pass√©s √† la commande

---

## üìö Commandes Disponibles

| Commande            | Description                                                | Fichier               |
| ------------------- | ---------------------------------------------------------- | --------------------- |
| `/create-cmd`       | G√©n√®re une nouvelle commande personnalis√©e (mode it√©ratif) | `create-cmd.md`       |
| `/commit`           | Analyse le code et g√©n√®re un message de commit uniforme    | `commit.md`           |
| `/doc`              | Agr√®ge les CHANGENOTES en CHANGELOG versionn√©              | `doc.md`              |
| `/clean-migrations` | Archive les migrations EF par version avec FastBuild       | `clean-migrations.md` |

---

## üîß Ressources

- **Best Practices** : `.github/github-copilot-cmd/best-practices.md` ‚Äî Catalogue des bonnes pratiques par domaine
- **Exemples** : `.github/github-copilot-cmd/examples/` ‚Äî Commandes de r√©f√©rence gold-standard

---

## ‚ö° R√®gles Globales

Toutes les commandes doivent respecter ces principes :

1. **Validation des pr√©requis** ‚Äî V√©rifier les conditions avant ex√©cution
2. **Pas d'interactif** ‚Äî Aucune commande demandant une saisie utilisateur
3. **Exit silencieux** ‚Äî Si rien √† faire, terminer sans message
4. **Pas de verbose** ‚Äî Messages concis, pas de d√©tails inutiles
5. **Pas de signatures** ‚Äî Jamais de "Generated by..." ou √©quivalent
6. **Gestion des erreurs** ‚Äî Reporter les erreurs clairement, sans verbosit√©
7. **Mode --help** ‚Äî Si `$ARGUMENTS` contient `--help` ou `-h`, afficher l'aide de la commande

### Mode Help (`--help` / `-h`)

Quand l'utilisateur tape `/command --help`, afficher un r√©sum√© concis :

```
/<command> ‚Äî <description courte>

Usage:
  /command [options] [arguments]

Options:
  <liste des arguments disponibles>

Examples:
  /command                  ‚Üí comportement par d√©faut
  /command --option         ‚Üí avec option
```

> ‚ö†Ô∏è **IMPORTANT** : En mode help, NE PAS ex√©cuter la commande, juste afficher l'aide.

---

## üöÄ Cr√©ation de Nouvelles Commandes

Pour cr√©er une nouvelle commande, utiliser :

```
/create-cmd <nom-commande>
```

Le g√©n√©rateur `/create-cmd` :

- Analyse le sujet demand√©
- Propose un draft complet (Description, Allowed Tools, Validation, Workflow, Rules)
- It√®re avec l'utilisateur pour am√©liorer
- Cr√©e le fichier `.github/github-copilot-cmd/<nom>.md`
- Propose d'enrichir `best-practices.md` avec les nouveaux patterns d√©couverts

---

## üìê Principes de D√©veloppement

### SOLID Principles

Appliquer syst√©matiquement les principes SOLID dans tout le code g√©n√©r√© :

#### **S** ‚Äî Single Responsibility Principle (Responsabilit√© Unique)

- Une classe, fonction ou m√©thode doit avoir **une et une seule raison d'√™tre**
- √âviter les classes surcharg√©es de responsabilit√©s
- Favorise la modularit√© et facilite la maintenance

#### **O** ‚Äî Open/Closed Principle (Ouvert/Ferm√©)

- Les entit√©s (classe, fonction, module) doivent √™tre **ferm√©es √† la modification** mais **ouvertes √† l'extension**
- Ajouter de nouvelles fonctionnalit√©s sans alt√©rer le code existant
- Privil√©gier l'h√©ritage, les interfaces et la composition

#### **L** ‚Äî Liskov Substitution Principle (Substitution de Liskov)

- Une instance de type T doit pouvoir √™tre **remplac√©e par une instance de son sous-type G** sans alt√©rer la coh√©rence du programme
- Garantit que les sous-classes peuvent √™tre utilis√©es de mani√®re interchangeable avec leurs classes de base
- Respecter le contrat d√©fini par la classe parent

#### **I** ‚Äî Interface Segregation Principle (S√©gr√©gation des Interfaces)

- Pr√©f√©rer **plusieurs interfaces sp√©cifiques** plut√¥t qu'une seule interface g√©n√©rale
- Les classes ne doivent pas d√©pendre de m√©thodes dont elles n'ont pas besoin
- R√©duit les couplages inutiles

#### **D** ‚Äî Dependency Inversion Principle (Inversion des D√©pendances)

- **D√©pendre des abstractions, pas des impl√©mentations**
- Favorise la modularit√©, la flexibilit√© et la r√©utilisabilit√©
- R√©duire les d√©pendances directes entre modules

### Conventions de Code

#### Attributs de Classe

- **TOUJOURS** pr√©fixer les attributs d'instance avec `this.`
- **JAMAIS** utiliser le pr√©fixe `_` pour les attributs priv√©s

**‚úÖ Correct** :

```csharp
public class Product
{
    private string name;

    public Product(string name)
    {
        this.name = name;  // Utilise "this."
    }
}
```

**‚ùå Incorrect** :

```csharp
public class Product
{
    private string _name;  // Pas de underscore

    public Product(string name)
    {
        _name = name;  // Pas de "this."
    }
}
```

---

## üí¨ Remarques Utilisateur

Cette section contient des feedbacks et pr√©f√©rences sp√©cifiques de l'utilisateur concernant le style de code, les patterns pr√©f√©r√©s, ou les ajustements √† apporter.

> **Note** : Cette section est enrichie au fur et √† mesure des retours utilisateur.

<!--
Exemples de remarques :
- Pr√©f√©rer async/await √† Task.Result
- Utiliser des records pour les DTOs immuables
- Logger tous les appels API
-->

---

## ‚ö° Optimisation de Workflow

### Batch Operations

**Parall√©lisation des Lectures** :

- Lire plusieurs fichiers en un seul appel d'outil
- Combiner les recherches ind√©pendantes
- √âviter les appels s√©quentiels quand possible

**√âdition en Batch** :

- Utiliser `multi_replace_string_in_file` pour √©diter plusieurs fichiers d'un coup
- Plus rapide et moins co√ªteux que des √©ditions s√©quentielles

### Lazy Evaluation

- Ne charger QUE le contexte n√©cessaire
- Pas de lecture exhaustive du projet si non requis
- Contexte diff√©r√© : charger selon les besoins du workflow

### Pattern Multi-Tours

Pour les t√¢ches complexes, d√©composer en phases :

1. **Discovery** ‚Äî Analyser et comprendre le contexte
2. **Planning** ‚Äî Proposer un plan d'action (STOP ‚Üí validation utilisateur)
3. **Execution** ‚Äî Appliquer les changements
4. **Validation** ‚Äî V√©rifier et corriger si n√©cessaire

**Quand d√©composer** :

- ‚úÖ T√¢che n√©cessitant > 10 recherches
- ‚úÖ Workflow incertain (exploration)
- ‚úÖ Besoin d'analyse complexe avant d√©cision

**Approche directe si** :

- ‚úÖ Workflow lin√©aire et connu
- ‚úÖ < 5 fichiers √† modifier
